# -*- coding: utf-8 -*-
"""6 parsing_xml_files.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RQ0WlQPRhm9Jy6zrD9mYAGVU61ZgrgeN
"""

import xml.etree.ElementTree as ET
import re
import pprint
from bs4 import BeautifulSoup
from dataclasses import dataclass
import json
from pathlib import Path

def read_tei(tei_file):
    with open(tei_file, 'r') as tei:
        soup = BeautifulSoup(tei, 'lxml')
        return soup
    raise RuntimeError('Cannot generate a soup from the input')

def elem_to_text(elem, default=''):
    if elem:
        return elem.getText(separator=' ', strip=True)
    else:
        return default

@dataclass
class Person:
    firstname: str
    middlename: str
    surname: str

class TEIFile(object):
    def __init__(self, filename):
        self.filename = filename
        self.soup = read_tei(filename)
        self._text = None
        self._title = ''
        self._abstract = ''

    def get_sections(self):
      '''
      get body text each section with its text
      '''
      body = self.soup.find("body")
      try:
        assert (body == self.soup.body)
      except:
        pass
      body_text = []
      if body:        
        all_divs = body.find_all('div')
        for div in all_divs:
          if not div.get("type"):# not reference or appendex
            section={"section":'', "sec_text":[]}    
            if len(list(div) ) > 0:    
              if list(div)[0].name != 'p':
                # get the title of the section
                section["section"] = list(div)[0]  
            # with that I got the text inside the p
            for par in div.find_all('p'): 
              text={"paragraph":"", "cite_spans":[]}
              text["paragraph"] = par.get_text(separator=' ', strip=True)
              text["cite_spans"] = self._get_grobid_cite_spans(par)
              text["cite_spans"] = self._get_cite_spans_links(par, text["cite_spans"])
              section["sec_text"].append(text)
            body_text.append(section)           
      return body_text
 

    def paper_title(self):
      '''
      return paper title
      '''
      if not self._title:
          self._title = self.soup.title.getText()
      return self._title

    def paper_abstract(self):
        '''
        return paper abstract
        '''
        if not self._abstract:
            abstract = self.soup.abstract.getText(separator=' ', strip=True)
            self._abstract = abstract
        return self._abstract

    def authors(self):
      '''
      return paper authors
      '''
      authors_in_header = self.soup.analytic.find_all('author')
      result = []
      for author in authors_in_header:
        # print("author  ",author )
        persname = author.persname
        if not persname:
          continue   
        firstname = elem_to_text(persname.find("forename", type="first"))
        middlename = elem_to_text(persname.find("forename", type="middle"))
        surname = elem_to_text(persname.surname)
        person = Person(firstname, middlename, surname)
        result.append({"first":person.firstname,"middle":person.middlename,"last":person.surname})
      self._authors = result
      return result

    def text(self):
        '''
        paper plain text
        '''
        print("text",self._text)
        if not self._text:
            divs_text = []
            
            for div in self.soup.body.find_all("div"):
              if not div.get("type"):
                    div_text = div.get_text(separator=' ', strip=True)
                    divs_text.append(div_text)

            plain_text = " ".join(divs_text)
            self._text = plain_text
        return self._text

    def _get_references(self):
      ref_list =[]
      ref_sec = self.soup.find('div', type='references')
      if not ref_sec:
          return ''
      else:
        i=1
        for elem in ref_sec:
          if len(list(elem))>1:
            for refs in elem:                 
              if len(list(refs))>1:                                                             
                    i= i + 1 
                    ref_list.append(refs)
      return ref_list

    def _build_bib_entry(self,elem):
        ref_dic ={"ref_id":"","ref_title":"","authors":[],"DOI":"","ISSN":"","ISSNe":"" ,"year":"","publisher":"","volume":"","issue":"" }
        ref_dic["ref_id"] = elem.get("xml:id")
        authors = elem.find_all('author')
        result = []
        for author in authors:
          persname = author.persname
          if not persname:
              pass   
          firstname = elem_to_text(persname.find("forename", type="first"))
          middlename = elem_to_text(persname.find("forename", type="middle"))
          surname = elem_to_text(persname.surname)
          person = Person(firstname, middlename, surname)
          per={}
          per["fisrt"] = person.firstname
          per["middle"] = person.middlename
          per["last"] = person.surname
          result.append(per)            
        ref_dic["authors"]= result               
        title = elem.find_all("title")[0]
        ref_dic["ref_title"] = title.get_text(separator=' ', strip=True)
        idno_elem = elem.find_all('idno')
        if idno_elem:
          if len(idno_elem)>1:
            for elem in idno_elem:
              elem_type = elem.get("type")
              if elem_type == 'DOI':
                ref_dic["DOI"] = elem.get_text(separator=' ', strip=True)
              elif elem_type == 'ISSN': 
                ref_dic["ISSN"] = elem.get_text(separator=' ', strip=True)
              elif elem_type == 'ISSNe': 
                ref_dic["ISSNe"] = elem.get_text(separator=' ', strip=True)

        date_ = elem.find('date')
        if  date_:
          ref_dic["year"] = date_.get("when")
        else:
          ref_dic["year"] = date_


        publisher = elem.find('publisher')
        if not publisher :
          pass
        else:
          ref_dic["publisher"] = publisher.get_text(separator=' ', strip=True)
        biblscope = elem.find_all('biblscope')
        if len(biblscope) ==0:
          pass
        else:            
            for bib in biblscope:
              unit = bib.get("unit")
              if unit =="volume":
                ref_dic["volume"] = bib.get_text(separator=' ', strip=True)
              if unit =="issue":
                ref_dic["issue"] = bib.get_text(separator=' ', strip=True)  
        return ref_dic

    def refrences(self):
      '''
      Get all references
      '''
      bib_entries=[]# for all metadata
      ref_list=[] # for all references
      ref_list = self._get_references()
      for i, elem in enumerate(ref_list):
        ref_dic = self._build_bib_entry(elem)    
        bib_entries.append(ref_dic)     
      return bib_entries  

    def parsepaper(self): 
      '''
      Parse paper
      '''
      self.paper={}
      self.papermeta = {}
      self.papermeta["title"] = self.paper_title()
      self.papermeta["authors"] =  self.authors()
      
      self.papermeta["abstract"] =  self.paper_abstract()
      #self.papermeta["DOI"] =  self.doi()
      self.paper["meta"] = self.papermeta
      self.paper["body"] = self.get_sections()
      self.paper["references"] = self.refrences()
      return self.paper       

    def _get_cite_spans(self,par):
      '''
       private method for getting citation in a aparagraph
      input: text represent the text of one section from article specified outside this function
      output: dataset dictionary contains {number of sentence:(x,y)}; x the citation(s) , y the sentence that contains citations 
      '''
      dataset = []
      text = par.get_text(separator=' ', strip=True)
      cite_spans = []

      # for all types of citations
      regex_find_citation = r"\(\s?(([A-Za-z\-]+\s)+([A-Za-z\-]+\.?)?,?\s\d{2,4}[a-c]?(;\s)?)+\s?\)|\
                              \[(\d{1,3},\s?)+\d{1,3}\]|\
                              \[[\d,-]+\]|(\([A-Z][a-z]+, \d+[a-c]?\))|\
                              ([A-Z][a-z]+ (et al\.)? \(\d+[a-c]?\))|\
                              [A-Z][a-z]+ and [A-Z][a-z]+ \(\d+[a-c]?\)]"


      #     get references from xml.tei file paragraph
      idx_list = []
      refs_idx = par.find_all('ref', type="bibr")      
      if refs_idx :
        #print("refs_idx", refs_idx)
        for idx in refs_idx:
          target = idx.get("target")
          if target:
            idx_list.append(idx.get("target")[1:])

       #   join rferences with the dataset
      if len(idx_list) > 1:  # got it from beautifulsoup
        cite_spans = list({"text":i.group(),"start":i.start(),"end":i.end()} for i in re.finditer(reg, text)) # got it from regular expression
      i = 0
      
      for  item in cite_spans:  # cite_spans=[{"text":[1],"start":4,"end":6}, {"text":[1,2],"start":10,"end":14}]        
        refs = item["text"]
        reg_year = r'\d{4}'
        years = re.findall(reg_year, refs)
        count = len(years)

        if count > 1 :
          refs = refs.split(';')
        elif count == 1 :
          pass
        else:
          refs = item["text"][1:-1]
          refs = refs.split(',')          
          count = len(refs)

        item["refs_id"] = []
       
        for _ in range(count):  
          try:        
            links[idx_list[i]].append(idx_list[i]) 
            i = i+1    
          except:   
            pass  
      if cite_spans:
        dataset.append({"cite_spans":cite_spans}) 
  
      return dataset

    def _get_cite_spans_links(self,par, idx_list):  
      i = 0
      refs_idx = par.find_all('ref', type="bibr")      
      if refs_idx :
        if len(idx_list) == len(refs_idx):
        #print("refs_idx", refs_idx)
          for idx in refs_idx:
            target = idx.get("target")
            if target:
              idx_list[i]["entry"] =idx.get("target")[1:]
              i += 1
         
      return idx_list    

    def _get_grobid_cite_spans(self,par):  
      text = par.get_text(separator=' ', strip=True)
      # all kind of citations
      r1 = r"\(\s?(([A-Za-z\-]+\s)+([A-Za-z\-]+\.?)?,?\s\d{2,4}[a-c]?(;\s)?)+\s?\)|"
      r2=  r"\[(\d{1,3},\s?)+\d{1,3}\]|"
      r3 = r"\[[\d,-]+\]|(\([A-Z][a-z]+, \d+[a-c]?\))|"
      r4 = r"([A-Z][a-z]+ (et al\.)? \(\d+[a-c]?\))|"
      r5 = r"[A-Z][a-z]+ and [A-Z][a-z]+ \(\d+[a-c]?\)]"                                             

      regex_find_citation = r1 + r2 + r3 + r4 + r5
      return list({"text":i.group(),"start":i.start(),"end":i.end()} for i in re.finditer(regex_find_citation , text))
   
    def to_json(self, path):
      '''
       parse paper to json file
      '''
      result= self.parsepaper()
      # res = json.dumps(result)
      with open(path, "w+") as json_file: 
        json.dump(result, json_file)



